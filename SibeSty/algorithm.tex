% !TeX encoding = windows-1251
% !TEX root = template.tex
\section{Алгоритм для $appSVP_{\gamma}$ на $q$-арной решетке}

В этом разделе мы представим комбинаторный алгоритм, который получая на входе $A \in \Z_q^{n \times 2n}$ and $c_{\gamma} < c_q/2 - 1/2$, выводит вектор $\vec{v} \in \qLATTp(A) \subset \Z_q^{2n}$ такой что \ $\| \vec{v} \| \leq n^{c_{\gamma}+c_q/2+1/2}$.\footnote{E: непонятно, откуда взяты эти константы и что они обозначают. Не определена граница Минковского для беск. нормы. \\ Д: Изучив ваше описание задачи $appSVP$ на $q$-арной решетке удалось узнать следующее: Чтобы увидеть связь между SIS и аппроксимированной задачей SVP, рассмотрим $m$-мерную $q$-арную решетку  $\qLATTp(\AMat) = \{ \xvec \in \Z^m \colon \AMat \xvec = 0 \mod q \}$. Решением $appSVP$ на $\qLATTp(\AMat)$ является вектор $\vvec \in \qLATTp(\AMat)$ длины $\|\vvec \| \leq \gamma \lambda_1(\qLATTp(\AMat))$ и таким образом, это является решением задачи SIS, когда $\gamma$ выбрана подходящим образом. Из границы Минковского, мы знаем, что $\lambda_1(\qLATTp(\AMat) \leq \sqrt{m} q^{n/m}$. Следовательно, если мы зададим $q=\bigO(n^{\cq})$, $\gamma  = \bigO(n^{\cg})$ для констант $\cq>1, \cg$, и возьмем $m = \TLandau(n)$, решением $appSVP$ будет вектор длины $\|\vvec \| \leq n^{\cg + \cq/2 + 1/2}$. Значения $\cg$ проистекают из связи между SIS с наихудшими случаями задач на решетках. С момента доказательства Ajtai'я, константа была улучшена с изначальной $\cg=8+\smallo(1)$ до $\cg=2.5+\smallo(1)$ и, наконец, до $\cg=1+\smallo(1)$. В понятиях SIS, $\cg$ известна как Ajtai's фактор связи. Мы накладываем на $\cg$ естественное ограничение, которое исходит из факта, что мы хотим избежать тривиальных решений длины $q$, а именно $\cg<\cq/2 - 1/2$.\\
	E: именно так. Эти рассуждения надо грамотно оформить и перенести в основной текст. Одна ошибка: граница $\|\vvec \| \leq n^{\cg + \cq/2 + 1/2}$ верна для конкретного $m$, в случае $m = \Theta(n)$, который вы рассматриваете, граница зависит от константы перед $n$ в $\Theta$ обозначении
}

Приведем теперь детальный обзор алгоритма.

Идея состоит в разделении размерности решетки $2n$ на $k$ блоков $d_1,...,d_k$, т.е. $\sum_{i = 1}^k d_i = 2n$. Мы также выбираем $k$ положительных значений $R_1,...,R_k$, где $R_i < q/2$ для всех $i$. \footnote{E:интервал для $j$? \\ Д: Честно говоря, немного не понимаю о каком $j$ идет речь. Если я правильно понял, $R_i$ это длины кубов. \\E: $j$ здесь не должно быть, сейчас все ок} Алгоритм продолжается $k$ шагов.

На первом шаге мы ищем пары векторов решетки $(\vec{v_1}, \vec{v_2})$, такие что
	\[
	\Big\lfloor \frac{[\vec{v_1}]_1^{d_1}}{R_1} \Big\rceil =  \Big\lfloor \frac{[\vec{v_2}]_1^{d_1}}{R_1} \Big\rceil.
	\]

Иными словами, мы разделяем наш $q$-арный куб $[- \frac{q-1}{2}, \frac{q-1}{2}]^{d_1}$ на множество меньших кубов $[-R_1, R_1]^{d_1}$  и ищем пары $(\vec{v_1}, \vec{v_2})$, чьи первые $d_1$ координат лежат в одном кубе. В нашем алгоритме мы задаем $R_1 = n^{\smallo(1)} \ll q$,  и мы можем регулировать выбор $R_1$ так, что малые кубы делят большой куб равномерно (Очевидно, что не при всяком выборе $R_1$ мы получим такое идеальное разбиение. Об $R_1$, которое максимально приближает нас к идеальному разбиению и идет речь.).

Как только два таких вектора найдены, мы вычитаем один из другого и отправляем результат в список $L_1$. Важно отметить, что мы можем ограничить $l_{\infty}$ - норму элементов в $L_1$: $\| [\vec{v_1} - \vec{v_2}]_1^{d_1}\|_{\infty} \leq R_1$. Выводом шага 1 является множество векторов с ограниченной $l_{\infty}$ - нормой на их первых $d_1$ координатах. На втором шаге мы используем векторы из $L_1$ для поиска пар, которые лежат в одном и том же $[-R_2, R_2]^{d_2}$ кубе на их $d_1 + 1,...,d_2$ координатах аналогично шагу 1. Выводом шага 2 является список $L_2$ векторов ограниченных в $l_{\infty}$ - норме по координатам $1,...,d_1$ и $d_1 + 1,...,d_2$.

Повторяя эту процедуру для всех $k$ шагов, мы закончим с векторами решетки для которых мы можем ограничить их $l_{\infty}$ - норму на всех $2n$ координатах. Из верхней границы длины выходных данных, мы найдем оптимальное по $k$. Обсуждение как выбрать $R_i$-ые и $k$ оставим на следующий пункт.

Существует простой трюк, который значительно улучшает время работы алгоритма. Мы можем записать нашу входную матрицу $A \in \Z_q^{n \times 2n}$ как $A = [A_1 | A_2]$, где $A_i \in \Z_q^{n \times n}$. С высокой вероятностью, $A_1$ обратима по mod $q$, позволяя нам записать $A = [Id_n | A^{'}]$, где $A^{'} = A^{-1}_1 A_2$ mod $q$. По сути эта процедура приводит $q$ - арный код, сгенерированный $A$, в систематическую форму. Легко проверить, что базис $\qLATTp(A)$ имеет вид 
	\begin{equation} \label{eq:BasisD}
	D = \begin{pmatrix}
	-A' & qId_n \\
	Id_{n} & 0
	\end{pmatrix}.
	\end{equation}

Теперь мы используем этот базис для генерации векторов решетки, чтобы произвести начальный поиск. Выберем $\vec{x}  = (x_1, \ldots, x_n, x_{n+1}, x_{2n}) \in \Z_q^{2n}$ и произведем векторы
\[
D \vec{x} \bmod q = (y_1,  \ldots,  y_n,  x_{n+1}, \ldots, x_{2n})^{\transpose}.
\]
Таким образом, мы можем уже ограничить $l_{\infty}$ - норму векторов крайних правых $n$ координат выбрав $(x_{n+1},...,x_n)$, скажем, меньше, чем $R_1$ (как будто мы уже распределили по корзинам правую часть). Мы отправляем векторы такого вида в наш начальный список $L_0$. Элементы из этого списка позволят нам произвести наш процесс 'cube-bucketing' на оставшихся левых $n$ координатах только в отличие от $2n$.

В этом разделе приведен алгоритм на псевдо-коде. Массив $T$ в псевдо-коде служит таблицей поиска: на шаге $i$, он проиндексирован $d_i$-мерными векторами (корзинами) $b$ и всякий раз, когда мы нашли вектор $\vec{v}$, такой, что $\Big\lfloor \frac{[\vec{v_1}]_1^{d_1}}{R_1} \Big\rceil = b$, мы смотрим пуст $T[b]$ или нет. В последнем случае, найдена коллизия и новый вектор\footnote{E: поясните здесь коротко, что вы понимаете под ``новым'' вектором \\ Д: Как я понял из самого кода алгоритма, цель последнего цикла найти корзину для $\vec{v}\mkern2mu[l_i, \ldots, l_{i-1}]$ и как видно из else в список $L_i$ добавляется $T[b] - \vec{v}$} добавляется в $L_i$.

\begin{algorithm}[t]
	\caption{$appSVP_{\gamma}$ на $q$-арной решетке}
	\label{alg:ApproxSVP}
	\textbf{Вход:} $D$ -- базис решетки $\qLATTp(A) \subset \Z_q^{2n}$ заданный как в ~(\ref{eq:BasisD}), $\gamma = n^{c_{\gamma}}$ -- фактор аппроксимации, $c_{\gamma}>0$ \\
	\textbf{Выход:} $L_k$ --список векторов из $\qLATTp(A)$, где все векторы нормы $\| \vec{v} \| \leq n^{c_{\gamma}+c_q/2+1/2}$;
	
	\begin{algorithmic}[1]
		
		\STATE Задаем границы просеивания $R_i$ как $R_1 = n^{\smallo(1)}$ и $R_i = \sqrt{2}^{i-1} R_1$ для $i \geq 2$.
		\STATE Задаем длину блоков $d_i$ как in в ~(\ref{eq:d_i}) и границы каждого блока $(l_{i-1}, \ldots, l_i)$ такие, что \ $l_{i}-{l_{i-1}} = d_i$ и $l_k = 1, l_0 = n$.
		
		\REPEAT %\COMMENT{Создаем список $L_0$}
		\STATE Выбираем $\vec{x} \in \Z_q^{2n}$ такой, что \ $\| [\vec{x}]_{n+1}^{2n} \|_{\infty} \leq R_1$
		\STATE $L_0 \gets L_0 \union \{D\vec{x} \bmod q\} $
		\UNTIL {$L_0$ достаточно большой}
		
		\STATE $T \gets \emptyset$ %\COMMENT{Инициализируем массив $T$ проиндексированный корзинами}
		\FORALL {$i=1 \ldots k$} \label{algline:ForLoop1}
		\FORALL { $\vec{v} \in L_{i-1}$} \label{algline:ForLoop2}
		\STATE $b \gets \Big\lfloor \frac{[\vec{v}]_{l_i}^{l_{i-1}}}{R_i} \Big\rceil$ %\COMMENT{Ищем корзины для $\vec{v}\mkern2mu[l_i, \ldots, l_{i-1}]$}
		\IF{$T[b] = \emptyset$}
		\STATE $T[b] \gets \vec{v}$
		\ELSE
		\STATE $L_{i} \gets L_{i} \union \{T[b] - \vec{v} \}$
		\STATE $T[b] \gets \emptyset$
		\ENDIF
		\ENDFOR
		\ENDFOR
		\STATE \RETURN $L_k$
	\end{algorithmic}
	
	\vspace{10pt}
	
\end{algorithm}