% !TeX encoding = windows-1251
% !TEX root = template.tex
\section{Анализ}

Полагаем, что описанный алгоритм $appSVP_{\gamma}$ на $q$-арной решетке как и все алгоритмы такого типа, имеет и время работы и оценку памяти вида $2^{\const + \smallo(1)}$ \footnote{E: вы забыли $n$ в показателе} для некоторой константы $\const$. Наша цель определить $\const$ как функцию от параметров входа: $\cg$, где $\gamma = \bigO(n^{\cg})$ и $\cq$, где $q = \bigO(n^{\cq})$. Рассмотрим средние случаи и покажем в нашем анализе ожидаемое время работы и оценку памяти.

Рассмотрим компромисс между временем выполнения и затраченной памятью, достигнутый алгоритмом. Напомним, что на $i$ шаге, одна запись в таблице $T$ представляет одну корзину, которая является одним из малых кубов $[-R_i/2, R_i/2]^{\ell_i}$ внутри большого куба $[-\frac{q-1}{2}, \frac{q-1}{2}]^{\ell_i}$. Мы рассчитываем, что все записи таблицы $T$ будут заполнены после того, как мы распределим по корзинам (число корзин)\footnote{E: так математические аргументы не оформляют, задайте переменную для числа корзин}-векторов решетки из $L_{i-1}$ (здесь мы используем тот факт,\footnote{E: это эвристика, не факт} что элементы из $L_{i-1}$, расположенные на блоке $\ell_i$, равномерно распределены в $[-\frac{q-1}{2}, \frac{q-1}{2}]^{\ell_i}$). Следовательно, после распределения по корзинам ($2 \cdot$ число корзин)-векторов решетки из $L_{i-1}$, мы рассчитываем отправить (число корзин)-векторов решетки в $L_i$. В итоге, списки становятся короче как минимум в $2$ раза на уровень. После $k$ уровней, мы рассчитываем $|L_k| = \TLandau(2^{-k} |L_0|)$.

Анализ далее раскрывает, что $k = \TLandau(\log n)$, и следовательно, выходной список $L_k,$ как ожидается будет только в $\poly(n)$-раз короче, чем входной список $L_0$. Позднее в доказательстве, мы увидим, что число корзин на каждом уровне будет экспоненциально по $n$, следовательно, чтобы найти хотя бы одну коллизию $i$, нам необходимо экспоненциально много векторов решетки в списке $L_{i-1}$. Поэтому мы игнорируем $\poly(n)$-множители получающиеся в результате того факта, что мы теряем примерно половину списка на каждом шаге. Также, число вычислений, которые мы производим за одну корзину составляет только $\bigO(n)$ посколько мы складываем два $n$-мерных вектора. Таким образом, и ожидаемое время работы и оценка памяти равны (с точностью до $\poly(n)$-множителей) числу корзин.

Интуитивно понятно, что было бы полезно выполнить большое количество шагов $k$ поскольку это приведет к уменьшению длины блоков $\ell_i$, что в свою очередь ускоряет обнаружение колизий. Однако мы должны задать $k$ таким, что $k = \TLandau(\log n)$ где константа в $\TLandau$ в конечном итоге будет зависеть от $\cg$ и $\cq$. Эта граница исходит из того факта, что каждый раз, когда мы производим сложение двух векторов, которые находятся в одной корзине, $\ell_{\infty}$-норма результирующего вектора на \emph{уже рассмотренных} блоках $\ell_1, \ldots, \ell_{i-1}$ увеличивается (в среднем) в $\sqrt{2}$ раз.\footnote{E: это неверная оценка для беск.нормы. Нарисуйте куб и сложите два случайных вектора из него. Посмотрите, чем ограничен результат} Поэтому укорачивание $\ell_{\infty}$-нормы с $q$ до $\sqrt{2}R_i$ на блоке\footnote{E: Множители перед $R_i$ должны быть изменены соответственно} увеличивает $\ell_{\infty}$-норму вектора на $\sqrt{2}$ в блоках, стоящих в правой части. Наконец, на координатном блоке $[d_{i-1}, \ldots, d_{i}]$ длины $\ell_i$, мы имеем $\| [\vvec\mkern3mu]_{d_i}^{d_{i-1}} \|_{\infty} \leq 2^{\frac{k-i+1}{2}} R_i $ для $\vvec \in L_k$. Следовательно, выбор $k$ ограничен верхней границей Евклидовой\footnote{E: про евклидову норму стоит забыть } длины $\vvec$, которую мы должны вывести.

В доказательстве ниже мы покажем, как задать длины блоков $\ell_i$, $\ell_\infty$-норму границы $R_i$, и число шагов $k$.

\begin{Theorem} Алгоритм~\ref{alg:ApproxSVP} получает на входе (1) базис решетки $\DMat \in \Z_q^{2n \times 2n}$ как в ~(\ref{eq:BasisD}) для решетки $\qLATTp(A)$ с $q = \bigO(n^{\cq})$ и (2) фактор аппроксимации $\gamma = \bigO(n^{\cg})$, выводит вектор $\vvec \in \qLATTp(A)$ длины $\|\vvec \| \leq n^{\cg+\cq/2 + 1/2}$ в ожидаемое время $T(appSVP_{\gamma})=2^{(\const+\smallo(1)) n}$, где
	\begin{equation} \label{eq:AppSVPRT}
		\const = \tfrac{1}{2 \ln \big( \frac{\cq}{\cq/2-\cg} \big)}.
	\end{equation}
\end{Theorem}


%\begin{Proof}
Ожидаемое время необходимое для заполнения всех корзин на шаге $i$ и, таким образом, для создания списка $L_{i}$ определяется количеством корзин или, эквавалентно, числу $\ell_i$-мерных кубов $[-R_i/2, R_i/2]^{\ell_i}$ которые `вписаны` в большой куб $[-\frac{q-1}{2}, \frac{q-1}{2}]$. Это число задается дробью, где в числителе и знаменателе находятся два объема:
	\[
		\E[\text{число корзин на уровне i}]= \frac{\vol([-\frac{q-1}{2}, \frac{q-1}{2}]^{d_i})}{\vol([-R_i/2, R_i/2]^{d_i})} = \TLandau \Big( \Big(\frac{q}{R_i}\Big)^{d_i}\Big).	
	\]
Это (с точностью до $\poly(n)$-множителей) ожидаемое время работы внутреннего цикла for (строка \ref{algline:ForLoop2}).
Как будет показано ниже, число шагов $k$ будет иметь размер $k = \TLandau(\log n)$ и следовательно, внешний цикл for на строке \ref{algline:ForLoop1} в Алгоритме.~\ref{alg:ApproxSVP} влияет на время работы только $\poly(n)$-множителем.

Таким образом, асимптотически, мы имеем $\big(\frac{q}{R_i}\big)^{d_i} = 2^{\const n}$, откуда следует, что
	\begin{equation} \label{eq:d_i}
		d_i = \frac{\const n}{\log q - \log R_i}.
	\end{equation}
	
В дополнение, мы имеем $\sum_{i=1}^k d_i = n$. Сделаем вывод по $\const$ из этих двух равенств.
	
Но перед тем как делать это, получим верхнюю границу для $k$. Ожидаемая длина вектора $\vvec$ в списке $L_k$ ограничена сверху как 
\[
\| \vvec \| \leq \sqrt{2 R_k^2 d_k + 4 R_{k-1}^2 d_{k-1} + \ldots + 2^{k-1} R_2^2 d_2 + 2^k R_1^2 d_1 + 2^k R_1^2 n}.
\]
Легко доказать, что если мы зададим $R_{i+1} = \sqrt{2} R_i$, первые $k$ слагаемых в нашей границе для $\|\vvec \|$ вносят вклад в общую сумму в равной степени. Наконец, мы получаем $\| \vvec \| \leq \sqrt{2 2^{k} R_1^2 n}$. Эта граница должна быть меньше, чем $n^{\cg +\cq/2 +1/2}$. Если мы зададим первую границу $R_1$ столь же малой, как $R=n^{\smallo(1)}$, неравенство $\sqrt{2 2^{k} R_1^2 n} \leq n^{\cg +\cq/2 +1/2}$ приводит к $k \leq 2 (\cg+\cq/2 + \smallo(1)) \log n$. Мы берем верхнюю границу как значение для $k$.

Поскольку мы задали $R_i = \sqrt{2}^{i-1} R_1$, мы теперь можем вычислить сумму $\sum_{i=1}^k d_i$ как
	\[	
	\sum_{i=1}^{k} \frac{\const n}{\log \tfrac{q}{ R_1} - \tfrac{1}{2}(i-1)} \leq  \int\limits_{i=0}^{k-1} \frac{\const n  \d i}{\log (\tfrac{q}{ R_1}) - \tfrac{1}{2}i} = - 2\const n \Big( \ln(\log \tfrac{q}{ R_1} - \tfrac{1}{2}i) \Big|_0^{k-1} \Big) =
	\]
	\[
	= 2\const n \ln \Big( \frac{\log \tfrac{q}{ R_1}}{\log \tfrac{q}{ R_1} - \tfrac{1}{2} (k-1)} \Big).
	\]
Ошибка, возникающая при аппроксимации суммы интегралом вносится в $\smallo(1)$-член в показателе.
Из фактов, что сумма всех $d_i$ равна $n$, $k=2 (\cg+\cq/2)\log n$, и $R_1 = n^{\smallo(1)}$, мы получаем
	\[\const = \frac{1}{2 \ln \big( \tfrac{\cq}{\cq/2-\cg} \big)} +\smallo(1).\]
	\vspace{-13pt}
%\end{Proof}

\begin{Remark}
Из доказательства выше, легко сделать вывод, что $m=\cm \cdot n$, $\cm = \TLandau(1)$
 	\[
		\const = \frac{\cm -1 }{2 \ln \big( \frac{\cq}{\cq (1-1/\cm) - \cg} \big)}.
	\]
\end{Remark}