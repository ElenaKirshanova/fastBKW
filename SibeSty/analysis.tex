% !TeX encoding = windows-1251
% !TEX root = template.tex
\section{Анализ}

Полагаем, что описанный алгоритм $appSVP_{\gamma}$ на $q$-арной решетке как и все алгоритмы такого типа, имеет и время работы и оценку памяти вида $2^{(\const + \smallo(1))n}$ для некоторой константы $\const$. Наша цель определить $\const$ как функцию от параметров входа: $\cg$, где $\gamma = \bigO(n^{\cg})$ и $\cq$, где $q = \bigO(n^{\cq})$. Рассмотрим средние случаи и покажем в нашем анализе ожидаемое время работы и оценку памяти.

Рассмотрим компромисс между временем выполнения и затраченной памятью, достигнутый алгоритмом. Напомним, что на $i$ шаге, одна запись в таблице $T$ представляет одну корзину, которая является одним из малых кубов $[-R_i/2, R_i/2]^{\ell_i}$ внутри большого куба $[-\frac{q-1}{2}, \frac{q-1}{2}]^{\ell_i}$. Обозначим число корзин \#buckets за $K$. Мы рассчитываем, что все записи таблицы $T$ будут заполнены после того, как мы распределим по корзинам $K$-векторов решетки из $L_{i-1}$ (здесь мы используем эвристику, что элементы из $L_{i-1}$, расположенные на блоке $\ell_i$, равномерно распределены в $[-\frac{q-1}{2}, \frac{q-1}{2}]^{\ell_i}$). Следовательно, после распределения по корзинам $2 \cdot K$-векторов решетки из $L_{i-1}$, мы рассчитываем отправить $K$-векторов решетки в $L_i$. В итоге, списки становятся короче как минимум в $2$ раза на уровень. После $k$ уровней, мы рассчитываем $|L_k| = \TLandau(2^{-k} |L_0|)$.

Анализ далее раскрывает, что $k = \TLandau(\log n)$, и следовательно, выходной список $L_k,$ как ожидается будет только в $\poly(n)$-раз короче, чем входной список $L_0$. Позднее в доказательстве, мы увидим, что число корзин на каждом уровне будет экспоненциально по $n$, следовательно, чтобы найти хотя бы одну коллизию $i$, нам необходимо экспоненциально много векторов решетки в списке $L_{i-1}$. Поэтому мы игнорируем $\poly(n)$-множители получающиеся в результате того факта, что мы теряем примерно половину списка на каждом шаге. Также, число вычислений, которые мы производим за одну корзину составляет только $\bigO(n)$ посколько мы складываем два $n$-мерных вектора. Таким образом, и ожидаемое время работы и оценка памяти равны (с точностью до $\poly(n)$-множителей) числу корзин.

Интуитивно понятно, что было бы полезно выполнить большое количество шагов $k$ поскольку это приведет к уменьшению длины блоков $\ell_i$, что в свою очередь ускоряет обнаружение колизий. Однако мы должны задать $k$ таким, что $k = \TLandau(\log n)$ где константа в $\TLandau$ в конечном итоге будет зависеть от $\cg$ и $\cq$. Эта граница исходит из того факта, что каждый раз, когда мы производим сложение двух векторов, которые находятся в одной корзине, $\ell_{\infty}$-норма результирующего вектора на \emph{уже рассмотренных} блоках $\ell_1, \ldots, \ell_{i-1}$ увеличивается не более чем в $2$ раза. Поэтому укорачивание $\ell_{\infty}$-нормы с $q$ до $2R_i$ на блоке\footnote{E: Множители перед $R_i$ должны быть изменены соответственно} увеличивает $\ell_{\infty}$-норму вектора на $2$ в блоках, стоящих в правой части. Наконец, на координатном блоке $[d_{i-1}, \ldots, d_{i}]$ длины $\ell_i$, мы имеем $\| [\vvec\mkern3mu]_{d_i}^{d_{i-1}} \|_{\infty} \leq 2^{k-i+1} R_i $ для $\vvec \in L_k$.

В доказательстве ниже мы покажем, как задать длины блоков $\ell_i$, $\ell_\infty$-норму границы $R_i$, и число шагов $k$.

\begin{Theorem} Алгоритм~\ref{alg:ApproxSVP} получает на входе (1) базис решетки $\DMat \in \Z_q^{2n \times 2n}$ как в Ур.~\eqref{eq:BasisD} для решетки $\qLATTp(A)$ с $q = \bigO(n^{\cq})$ и (2) фактор аппроксимации $\gamma = \bigO(n^{\cg})$, выводит вектор $\vvec \in \qLATTp(A)$ длины $\|\vvec \| \leq n^{\cg+\cq/2 + 1/2}$ в ожидаемое время $T(appSVP_{\gamma})=2^{(\const+\smallo(1)) n}$, где
	\begin{center}
		$\const = \tfrac{1}{2 \ln \big( \frac{\cq}{\cq/2-\cg} \big)}$.
	\end{center}
\end{Theorem}


%\begin{Proof}
Ожидаемое время необходимое для заполнения всех корзин на шаге $i$ и, таким образом, для создания списка $L_{i}$ определяется количеством корзин или, эквавалентно, числу $\ell_i$-мерных кубов $[-R_i/2, R_i/2]^{\ell_i}$ которые `вписаны` в большой куб $[-\frac{q-1}{2}, \frac{q-1}{2}]$. Это число задается дробью, где в числителе и знаменателе находятся два объема:
	\[
		\E[\text{число корзин на уровне } i]= \frac{\vol([-\frac{q-1}{2}, \frac{q-1}{2}]^{d_i})}{\vol([-R_i/2, R_i/2]^{d_i})} = \TLandau \Big( \Big(\frac{q}{R_i}\Big)^{d_i}\Big).	
	\]
Это (с точностью до $\poly(n)$-множителей) ожидаемое время работы внутреннего цикла for (строка \ref{algline:ForLoop2}).
Как будет показано ниже, число шагов $k$ будет иметь размер $k = \TLandau(\log n)$ и следовательно, внешний цикл for на строке \ref{algline:ForLoop1} в Алгоритме~\ref{alg:ApproxSVP} влияет на время работы только $\poly(n)$-множителем.

Таким образом, асимптотически, мы имеем $\big(\frac{q}{R_i}\big)^{d_i} = 2^{\const \cdot n}$, откуда следует, что
	\begin{equation} \label{eq:d_i}
		d_i = \frac{\const \cdot n}{\log q - \log R_i}.
	\end{equation}
	
В дополнение, мы имеем $\sum_{i=1}^k d_i = n$. Сделаем вывод по $\const$ из этих двух равенств.
	
Но перед тем как делать это, получим верхнюю границу для $k$. Ожидаемая норма вектора $\vvec$ в списке $L_k$ ограничена сверху как\footnote{Е: выражение ниже справедливо для евклидовой нормы, для беск. должен фигурировать $\max$ \\ E(upd): и все таки нет. Я не понимаю, откуда взялись множители $d_i$ и $n$ - поясните.}
\[
\| \vvec \|_\infty \leq \max{\{2 R_k d_k, 4 R_{k-1} d_{k-1}, \ldots, 2^{k-1} R_2 d_2, 2^k R_1 d_1, 2^k R_1 n\}}
\]
Легко доказать, что если мы зададим $R_{i+1} = 2R_i$, первые $k$ элементов в нашей границе для $\|\vvec \|$ ведут себя одинаково. Наконец, мы получаем $\| \vvec \| \leq 2^{k} R_1^2 n$.\footnote{E: аналогично предыдущему комментарию: проверьте множитель $n$} Эта граница должна быть меньше, чем $n^{\cg +\cq/2 +1/2}$. Если мы зададим первую границу $R_1$ столь же малой, как $R=n^{\smallo(1)}$, неравенство $2^{k} R_1^2 n \leq n^{\cg +\cq/2 +1/2}$ приводит к $k \leq (\cg+\cq/2 + \smallo(1)) \log n$.\footnote{E: соответственно изменится значение для $k$, по моим прикидкам, двойки здесь быть не должно. Рассуждения ниже должны быть перепроверены \\ E(upd): у меня получился другой результат, не понятно куда ушла константа $1/2$} Мы берем верхнюю границу как значение для $k$.

Поскольку мы задали $R_i = \sqrt{2}^{i-1} R_1$,\footnote{E: уберите корень и перепроверьте вычисления ниже} мы теперь можем вычислить сумму $\sum_{i=1}^k d_i$ как
	\[	
	\sum_{i=1}^{k} \frac{\const n}{\log \tfrac{q}{ R_1} - \tfrac{1}{2}(i-1)} \leq  \int\limits_{i=0}^{k-1} \frac{\const n  \d i}{\log (\tfrac{q}{ R_1}) - \tfrac{1}{2}i} = - 2\const n \Big( \ln(\log \tfrac{q}{ R_1} - \tfrac{1}{2}i) \Big|_0^{k-1} \Big) =
	\]
	\[
	= 2\const n \ln \Big( \frac{\log \tfrac{q}{ R_1}}{\log \tfrac{q}{ R_1} - \tfrac{1}{2} (k-1)} \Big).
	\]
Ошибка, возникающая при аппроксимации суммы интегралом вносится в $\smallo(1)$-член в показателе.
Из фактов, что сумма всех $d_i$ равна $n$, $k=2 (\cg+\cq/2)\log n$,\footnote{E: это значение для $k$ противоречит тому, что выше} и $R_1 = n^{\smallo(1)}$, мы получаем
	\[\const = \frac{1}{2 \ln \big( \tfrac{\cq}{\cq/2-\cg} \big)} +\smallo(1).\]
	\vspace{-13pt}
%\end{Proof}

\begin{Remark}
Из доказательства выше, легко сделать вывод, что $m=\cm \cdot n$, $\cm = \TLandau(1)$
 	\[
		\const = \frac{\cm -1 }{2 \ln \big( \frac{\cq}{\cq (1-1/\cm) - \cg} \big)}.
	\]
\end{Remark}