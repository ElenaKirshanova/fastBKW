\documentclass[a4paper,12pt]{article}
\usepackage{sibecrypt}


\begin{document}

\section{Алгоритм для $appSVP_{\gamma}$ на $q$-арной решетке}

В этом разделе мы представим комбинаторный алгоритм, который получая на входе $A \in Z_q^{n \times 2n}$ and $c_{\gamma} < c_q/2 - 1/2$, выводит вектор $\vec{v} \in L^{\perp}_q (A) \subset Z_q^{2n}$ такой что \ $\| \vec{v} \| \leq n^{c_{\gamma}+c_q/2+1/2}$. Отметим, что мы задаем размерность решетки $m$ как $m=2n$. Такой выбор упрощает описание и необходим для улучшения алгоритма в дальнейшем.

Алгоритм представляет собой комбинаторный алгоритм типа BKW для задачи LWE адаптированный для задачи $appSVP_{\gamma}$. Приведем теперь его детальный обзор.

Идея состоит в разделении размерности решетки $2n$ на $k$ блоков $d_1,...,d_k$, т.е. $\sum_{i = 1}^k d_i = 2n$. Мы также выбираем $k$ положительных значений $R_1,...,R_k$, где $R_i < q/2$ для всех $i$. Алгоритм продолжается $k$ шагов.

На первом шаге мы ищем пары векторов решетки $(\vec{v_1}, \vec{v_2})$, такие что
\[
\Big\lfloor \frac{[\vec{v_1}]_1^{d_1}}{R_1} \Big\rceil =  \Big\lfloor \frac{[\vec{v_2}]_1^{d_1}}{R_1} \Big\rceil\footnote{Используя определение $[\vec{x}]_i^j = x_i\ldots x_j$ for $i \leq j$.}.
\]

Иными словами, мы разделяем наш $q$-арный куб $[- \frac{q-1}{2}, \frac{q-1}{2}]^{d_1}$ на множество меньших кубов $[-R_1, R_1]^{d_1}$  и ищем пары $(\vec{v_1}, \vec{v_2})$, чьи первые $d_1$ координат лежат в одном кубе. В нашем алгоритме мы задаем $R_1 = n^{o(1)} \ll q$,  и мы можем регулировать выбор $R_1$ так, что малые кубы делят большой куб равномерно.

Как только два таких вектора найдены, мы вычитаем один из другого и отправляем результат в список $L_1$. Важно отметить, что мы можем ограничить $l_{\infty}$ - норму элементов в $L_1$: в среднем,  $\| [\vec{v_1} - \vec{v_2}]_1^{d_1}\|_{\infty} \leq \sqrt{2}R_1$. Выводом шага 1 является множество векторов с ограниченной $l_{\infty}$ - нормой на их первых $d_1$ координатах. На втором шаге мы используем векторы из $L_1$ для поиска пар, которые лежат в одном и том же $[-R_2, R_2]^{d_2}$ кубе на их $d_1 + 1,...,d_2$ координатах аналогично шагу 1. Выводом шага 2 является список $L_2$ векторов ограниченных в $l_{\infty}$ - норме по координатам $1,...,d_1$ и $d_1 + 1,...,d_2$.

Повторяя эту процедуру для всех $k$ шагов, мы законичим с векторами решетки для которых мы можем ограничить их $l_{\infty}$ - норму на всех $2n$ координатах и следовательно, Евклидову норму. Из верхней границы длины выходных данных, мы найдем оптимальное по $k$. Обсуждение как выбрать $R_i$-ые и $k$ оставим на следующий пункт.

Существует простой трюк, который значительно улучшает время работы алгоритма. Мы можем записать нашу входную матрицу $A \in Z_q^{n \times 2n}$ как $A = [A_1 | A_2]$, где $A_i \in Z_q^{n \times n}$. С высокой вероятностью, $A_1$ обратима по mod $q$, позволяя нам записать $A = [Id_n | A^{'}]$, где $A^{'} = A^{-1}_1 A_2$ mod $q$. По сути эта процедура приводит $q$ - арный код, сгенерированный $A$, в систематическую форму. Легко проверить, что базис $L^{\perp}_q (A)$ имеет вид 
\begin{equation} \label{eq:BasisD}
	D = \begin{pmatrix}
	-A' & q Id_n \\
	Id_{n} & 0
	\end{pmatrix}.
\end{equation}

Теперь мы используем этот базис для генерации векторов решетки, чтобы произвести начальный поиск. Выберем $\vec{x}  = (x_1, \ldots, x_n, x_{n+1}, x_{2n}) \in Z_q^{2n}$ и произведем векторы
\[
D \vec{x} \bmod q = (y_1,  \ldots,  y_n,  x_{n+1}, \ldots, x_{2n})^{t}.
\]
Таким образом, мы можем уже ограничить $l_{\infty}$ - норму векторов крайних правых $n$ координат выбрав $(x_{n+1},...,x_n)$, скажем, меньше, чем $R_1$ (как будто мы уже распределили по корзинам правую часть). Мы отправляем векторы такого вида в наш начальный список $L_0$. Элементы из этого списка позволят нам произвести наш "cube-bucketing" процесс на оставшихся левых $n$ координатах только в отличие от $2n$.

Ниже приведен алгоритм на псевдо-коде. Массив $T$ в псевдо-коде служит справочной таблицей: на шаге $i$, он проиндексирован $d_i$-мерными векторами (корзинами) $b$ и всякий раз, когда мы нашли вектор $\vec{v}$, такой, что $\Big\lfloor \frac{[\vec{v_1}]_1^{d_1}}{R_1} \Big\rceil = b$, мы смотрим пуст $T[b]$ или нет. В последнем случае, найдена коллизия и новый вектор добавляется в $L_i$.

\begin{algorithm}[t]
	\caption{$appSVP_{\gamma}$ на $q$-арной решетке}
	\textbf{Вход:} $D$ -- базис решетки $L^{\perp}_q (A) \subset Z_q^{2n}$ заданный как в ~(\ref{eq:BasisD}), $\gamma = n^{c_{\gamma}}$ -- фактор аппроксимации, $c_{\gamma}>0$ \\
	\textbf{Выход:} $L_k$ --список векторов из $L^{\perp}_q (A)$, где все векторы нормы $\| \vec{v} \| \leq n^{c_{\gamma}+c_q/2+1/2}$;
	
	\begin{algorithmic}[1]
		
		\item Задаем границы просеивания $R_i$ как $R_1 = n^{o(1)}$ и $R_i = \sqrt{2}^{i-1} R_1$ для $i \geq 2$.
		\item Задаем длину блоков $d_i$ как in Eq.(4.18) и границы каждого блока $(l_{i-1}, \ldots, l_i)$ такие, что \ $l_{i}-{l_{i-1}} = d_i$ и $l_k = 1, l_0 = n$.
		
		\item \textbf{repeat}
		\item Выбираем $\vec{x} \in Z_q^{2n}$ такой, что \ $\| [\vec{x}]_{n+1}^{2n} \|_{\infty} \leq R_1$
		\item $L_0 \gets L_0  \cup \{D\vec{x} \bmod q\}$
		\item \textbf{until} {$L_0$ достаточно большой}
		
		\item $T \gets \emptyset$
		\item \textbf{for all} {$i=1 \ldots k$}
		\item	\textbf{for all} { $\vec{v} \in L_{i-1}$}
		\item		$b \gets \Big\lfloor \frac{[\vec{v}]_{l_i}^{l_{i-1}}}{R_i} \Big\rceil$
		\item		\textbf{if} {$T[b] = \emptyset$}
		\item			$T[b] \gets \vec{v}$
		\item		\textbf{else}
		\item			$L_{i} \gets L_{i} \cup \{T[b] - \vec{v} \}$
		\item			$T[b] \gets \emptyset$
		\item \textbf{return} $L_k$
	\end{algorithmic}
	
	\vspace{10pt}
	
\end{algorithm}

\end{document}

%\begin{Definition}
%\end{Definition}

%\begin{Theorem}
%\end{Theorem}